import { Injectable } from '@nestjs/common';
import * as sweph from 'sweph';
import {
  PanchangaDate,
  Location,
  TithiResult,
  NakshatraResult,
  YogaResult,
  KaranaResult,
  MasaResult,
  PanchangaResult,
} from './interfaces/panchanga.interface';

// Swiss Ephemeris constants (since they're not exported from the package)
const SE_SUN = 0;
const SE_MOON = 1;
const SE_GREG_CAL = 1;
const SEFLG_SWIEPH = 2;
const SE_CALC_RISE = 1;
const SE_CALC_SET = 2;
const SE_SIDM_LAHIRI = 1;

@Injectable()
export class PanchangaService {
  constructor() {
    // Initialize Swiss Ephemeris
    sweph.set_ephe_path('');
  }

  /**
   * Convert degrees, minutes, seconds to decimal degrees
   */
  private fromDms(degs: number, mins: number, secs: number): number {
    return degs + mins / 60 + secs / 3600;
  }

  /**
   * Convert decimal degrees to degrees, minutes, seconds
   */
  private toDms(deg: number): number[] {
    const d = Math.floor(deg);
    const mins = (deg - d) * 60;
    const m = Math.floor(mins);
    const s = Math.round((mins - m) * 60);
    return [d, m, s];
  }

  /**
   * Convert Gregorian date to Julian Day Number
   */
  private gregorianToJd(date: PanchangaDate): number {
    return sweph.julday(date.year, date.month, date.day, 0.0, SE_GREG_CAL);
  }

  /**
   * Convert Julian Day Number to Gregorian date
   */
  private jdToGregorian(jd: number): PanchangaDate {
    const result = sweph.revjul(jd, SE_GREG_CAL);
    return {
      year: result.year,
      month: result.month,
      day: result.day,
    };
  }

  /**
   * Get solar longitude at given Julian Day
   */
  private solarLongitude(jd: number): number {
    const result = sweph.calc_ut(jd, SE_SUN, SEFLG_SWIEPH);
    return result.longitude;
  }

  /**
   * Get lunar longitude at given Julian Day
   */
  private lunarLongitude(jd: number): number {
    const result = sweph.calc_ut(jd, SE_MOON, SEFLG_SWIEPH);
    return result.longitude;
  }

  /**
   * Get lunar latitude at given Julian Day
   */
  private lunarLatitude(jd: number): number {
    const result = sweph.calc_ut(jd, SE_MOON, SEFLG_SWIEPH);
    return result.latitude;
  }

  /**
   * Calculate sunrise time
   */
  private sunrise(jd: number, location: Location): number[] {
    const { latitude, longitude, timezone } = location;
    const result = sweph.rise_trans(
      jd - timezone / 24,
      SE_SUN,
      '',
      SEFLG_SWIEPH,
      SE_CALC_RISE,
      longitude,
      latitude,
      0,
    );

    if (result.error) {
      throw new Error(`Sunrise calculation error: ${result.error}`);
    }

    const rise = result.transitTime;
    return [rise + timezone / 24, ...this.toDms((rise - jd) * 24 + timezone)];
  }

  /**
   * Calculate sunset time
   */
  private sunset(jd: number, location: Location): number[] {
    const { latitude, longitude, timezone } = location;
    const result = sweph.rise_trans(
      jd - timezone / 24,
      SE_SUN,
      '',
      SEFLG_SWIEPH,
      SE_CALC_SET,
      longitude,
      latitude,
      0,
    );

    if (result.error) {
      throw new Error(`Sunset calculation error: ${result.error}`);
    }

    const setting = result.transitTime;
    return [
      setting + timezone / 24,
      ...this.toDms((setting - jd) * 24 + timezone),
    ];
  }

  /**
   * Calculate moonrise time
   */
  private moonrise(jd: number, location: Location): number[] {
    const { latitude, longitude, timezone } = location;
    const result = sweph.rise_trans(
      jd - timezone / 24,
      SE_MOON,
      '',
      SEFLG_SWIEPH,
      SE_CALC_RISE,
      longitude,
      latitude,
      0,
    );

    if (result.error) {
      return [0, 0, 0]; // Return zeros if moonrise doesn't occur
    }

    const rise = result.transitTime;
    return this.toDms((rise - jd) * 24 + timezone);
  }

  /**
   * Calculate moonset time
   */
  private moonset(jd: number, location: Location): number[] {
    const { latitude, longitude, timezone } = location;
    const result = sweph.rise_trans(
      jd - timezone / 24,
      SE_MOON,
      '',
      SEFLG_SWIEPH,
      SE_CALC_SET,
      longitude,
      latitude,
      0,
    );

    if (result.error) {
      return [0, 0, 0]; // Return zeros if moonset doesn't occur
    }

    const setting = result.transitTime;
    return this.toDms((setting - jd) * 24 + timezone);
  }

  /**
   * Calculate lunar phase (moon's position relative to sun)
   */
  private lunarPhase(jd: number): number {
    const solarLong = this.solarLongitude(jd);
    const lunarLong = this.lunarLongitude(jd);
    return (lunarLong - solarLong + 360) % 360;
  }

  /**
   * Unwrap angles to ensure ascending order
   */
  private unwrapAngles(angles: number[]): number[] {
    const result = [...angles];
    for (let i = 1; i < result.length; i++) {
      if (result[i] < result[i - 1]) {
        result[i] += 360;
      }
    }
    return result;
  }

  /**
   * Inverse Lagrange interpolation
   */
  private inverseLagrange(x: number[], y: number[], ya: number): number {
    let total = 0;
    for (let i = 0; i < x.length; i++) {
      let numer = 1;
      let denom = 1;
      for (let j = 0; j < x.length; j++) {
        if (j !== i) {
          numer *= ya - y[j];
          denom *= y[i] - y[j];
        }
      }
      total += (numer * x[i]) / denom;
    }
    return total;
  }

  /**
   * Calculate Tithi (lunar day)
   */
  calculateTithi(jd: number, location: Location): TithiResult[] {
    const timezone = location.timezone;
    const rise = this.sunrise(jd, location)[0] - timezone / 24;

    const moonPhase = this.lunarPhase(rise);
    const today = Math.ceil(moonPhase / 12);
    const degreesLeft = today * 12 - moonPhase;

    const offsets = [0.25, 0.5, 0.75, 1.0];
    const lunarLongDiff = offsets.map(
      (t) =>
        (this.lunarLongitude(rise + t) - this.lunarLongitude(rise) + 360) % 360,
    );
    const solarLongDiff = offsets.map(
      (t) =>
        (this.solarLongitude(rise + t) - this.solarLongitude(rise) + 360) % 360,
    );
    const relativeMotion = lunarLongDiff.map(
      (moon, i) => moon - solarLongDiff[i],
    );

    const approxEnd = this.inverseLagrange(
      offsets,
      relativeMotion,
      degreesLeft,
    );
    const ends = (rise + approxEnd - jd) * 24 + timezone;

    const result: TithiResult[] = [
      {
        number: today,
        name: this.getTithiName(today),
        endTime: this.toDms(ends),
      },
    ];

    // Check for skipped tithi
    const moonPhaseTmrw = this.lunarPhase(rise + 1);
    const tomorrow = Math.ceil(moonPhaseTmrw / 12);
    const isSkipped = (tomorrow - today + 30) % 30 > 1;

    if (isSkipped) {
      const leapTithi = today + 1;
      const degreesLeftLeap = leapTithi * 12 - moonPhase;
      const approxEndLeap = this.inverseLagrange(
        offsets,
        relativeMotion,
        degreesLeftLeap,
      );
      const endsLeap = (rise + approxEndLeap - jd) * 24 + timezone;

      result.push({
        number: leapTithi,
        name: this.getTithiName(leapTithi),
        endTime: this.toDms(endsLeap),
      });
    }

    return result;
  }

  /**
   * Calculate Nakshatra (lunar mansion)
   */
  calculateNakshatra(jd: number, location: Location): NakshatraResult[] {
    sweph.set_sid_mode(SE_SIDM_LAHIRI, 0, 0);
    const timezone = location.timezone;
    const rise = this.sunrise(jd, location)[0] - timezone / 24;

    const offsets = [0.0, 0.25, 0.5, 0.75, 1.0];
    const longitudes = offsets.map((t) => {
      const lunarLong = this.lunarLongitude(rise + t);
      const ayanamsa = sweph.get_ayanamsa_ut(rise + t);
      return (lunarLong - ayanamsa + 360) % 360;
    });

    const nak = Math.ceil((longitudes[0] * 27) / 360);

    const y = this.unwrapAngles(longitudes);
    const x = offsets;
    const approxEnd = this.inverseLagrange(x, y, (nak * 360) / 27);
    const ends = (rise - jd + approxEnd) * 24 + timezone;

    const result: NakshatraResult[] = [
      {
        number: nak,
        name: this.getNakshatraName(nak),
        endTime: this.toDms(ends),
      },
    ];

    // Check for skipped nakshatra
    const nakTmrw = Math.ceil((longitudes[longitudes.length - 1] * 27) / 360);
    const isSkipped = (nakTmrw - nak + 27) % 27 > 1;

    if (isSkipped) {
      const leapNak = nak + 1;
      const approxEndLeap = this.inverseLagrange(
        offsets,
        longitudes,
        (leapNak * 360) / 27,
      );
      const endsLeap = (rise - jd + approxEndLeap) * 24 + timezone;

      result.push({
        number: leapNak,
        name: this.getNakshatraName(leapNak),
        endTime: this.toDms(endsLeap),
      });
    }

    return result;
  }

  /**
   * Calculate Yoga
   */
  calculateYoga(jd: number, location: Location): YogaResult[] {
    sweph.set_sid_mode(SE_SIDM_LAHIRI, 0, 0);
    const timezone = location.timezone;
    const rise = this.sunrise(jd, location)[0] - timezone / 24;

    const ayanamsa = sweph.get_ayanamsa_ut(rise);
    const lunarLong = (this.lunarLongitude(rise) - ayanamsa + 360) % 360;
    const solarLong = (this.solarLongitude(rise) - ayanamsa + 360) % 360;
    const total = (lunarLong + solarLong) % 360;

    const yog = Math.ceil((total * 27) / 360);
    const degreesLeft = (yog * 360) / 27 - total;

    const offsets = [0.25, 0.5, 0.75, 1.0];
    const lunarLongDiff = offsets.map(
      (t) =>
        (this.lunarLongitude(rise + t) - this.lunarLongitude(rise) + 360) % 360,
    );
    const solarLongDiff = offsets.map(
      (t) =>
        (this.solarLongitude(rise + t) - this.solarLongitude(rise) + 360) % 360,
    );
    const totalMotion = lunarLongDiff.map((moon, i) => moon + solarLongDiff[i]);

    const approxEnd = this.inverseLagrange(offsets, totalMotion, degreesLeft);
    const ends = (rise + approxEnd - jd) * 24 + timezone;

    const result: YogaResult[] = [
      {
        number: yog,
        name: this.getYogaName(yog),
        endTime: this.toDms(ends),
      },
    ];

    // Check for skipped yoga
    const ayanamsaTmrw = sweph.get_ayanamsa_ut(rise + 1);
    const lunarLongTmrw =
      (this.lunarLongitude(rise + 1) - ayanamsaTmrw + 360) % 360;
    const solarLongTmrw =
      (this.solarLongitude(rise + 1) - ayanamsaTmrw + 360) % 360;
    const totalTmrw = (lunarLongTmrw + solarLongTmrw) % 360;
    const tomorrow = Math.ceil((totalTmrw * 27) / 360);
    const isSkipped = (tomorrow - yog + 27) % 27 > 1;

    if (isSkipped) {
      const leapYog = yog + 1;
      const degreesLeftLeap = (leapYog * 360) / 27 - total;
      const approxEndLeap = this.inverseLagrange(
        offsets,
        totalMotion,
        degreesLeftLeap,
      );
      const endsLeap = (rise + approxEndLeap - jd) * 24 + timezone;

      result.push({
        number: leapYog,
        name: this.getYogaName(leapYog),
        endTime: this.toDms(endsLeap),
      });
    }

    return result;
  }

  /**
   * Calculate Karana (half lunar day)
   */
  calculateKarana(jd: number, location: Location): KaranaResult {
    const rise = this.sunrise(jd, location)[0];
    const solarLong = this.solarLongitude(rise);
    const lunarLong = this.lunarLongitude(rise);
    const moonPhase = (lunarLong - solarLong + 360) % 360;
    const today = Math.ceil(moonPhase / 6);

    return {
      number: today,
      name: this.getKaranaName(today),
    };
  }

  /**
   * Calculate weekday (Vaara)
   */
  calculateVaara(jd: number): number {
    return Math.floor((jd + 1) % 7);
  }

  /**
   * Calculate lunar month (Masa)
   */
  calculateMasa(jd: number, location: Location): MasaResult {
    const ti = this.calculateTithi(jd, location)[0].number;
    const critical = this.sunrise(jd, location)[0];
    const lastNewMoon = this.newMoon(critical, ti, -1);
    const nextNewMoon = this.newMoon(critical, ti, 1);
    const thisSolarMonth = this.raasi(lastNewMoon);
    const nextSolarMonth = this.raasi(nextNewMoon);
    const isLeapMonth = thisSolarMonth === nextSolarMonth;
    let maasa = thisSolarMonth + 1;
    if (maasa > 12) maasa = maasa % 12;

    return {
      number: maasa,
      name: this.getMasaName(maasa),
      isAdhika: isLeapMonth,
    };
  }

  /**
   * Calculate day duration
   */
  calculateDayDuration(jd: number, location: Location): number[] {
    const srise = this.sunrise(jd, location)[0];
    const sset = this.sunset(jd, location)[0];
    const diff = (sset - srise) * 24;
    return [diff, ...this.toDms(diff)];
  }

  /**
   * Find new moon
   */
  private newMoon(jd: number, tithi: number, opt: number): number {
    let start: number;
    if (opt === -1) {
      start = jd - tithi;
    } else if (opt === 1) {
      start = jd + (30 - tithi);
    } else {
      start = jd; // Default fallback
    }

    const x = Array.from({ length: 17 }, (_, i) => -2 + i / 4);
    const y = x.map((i) => this.lunarPhase(start + i));
    const yUnwrapped = this.unwrapAngles(y);
    const y0 = this.inverseLagrange(x, yUnwrapped, 360);
    return start + y0;
  }

  /**
   * Calculate Raasi (zodiac sign)
   */
  private raasi(jd: number): number {
    sweph.set_sid_mode(SE_SIDM_LAHIRI, 0, 0);
    const solarLong = this.solarLongitude(jd);
    const ayanamsa = sweph.get_ayanamsa_ut(jd);
    const solarNirayana = (solarLong - ayanamsa + 360) % 360;
    return Math.ceil(solarNirayana / 30);
  }

  /**
   * Get complete Panchanga for a given date and location
   */
  getPanchanga(date: PanchangaDate, location: Location): PanchangaResult {
    const jd = this.gregorianToJd(date);

    return {
      date,
      location,
      tithi: this.calculateTithi(jd, location),
      nakshatra: this.calculateNakshatra(jd, location),
      yoga: this.calculateYoga(jd, location),
      karana: this.calculateKarana(jd, location),
      masa: this.calculateMasa(jd, location),
      vaara: this.calculateVaara(jd),
      sunrise: this.sunrise(jd, location),
      sunset: this.sunset(jd, location),
      moonrise: this.moonrise(jd, location),
      moonset: this.moonset(jd, location),
      dayDuration: this.calculateDayDuration(jd, location),
    };
  }

  // Helper methods for names
  private getTithiName(number: number): string {
    const names = [
      '',
      'Pratipad',
      'Dwitiya',
      'Tritiya',
      'Chaturthi',
      'Panchami',
      'Shashthi',
      'Saptami',
      'Ashtami',
      'Navami',
      'Dashami',
      'Ekadashi',
      'Dwadashi',
      'Trayodashi',
      'Chaturdashi',
      'Purnima',
      'Pratipad',
      'Dwitiya',
      'Tritiya',
      'Chaturthi',
      'Panchami',
      'Shashthi',
      'Saptami',
      'Ashtami',
      'Navami',
      'Dashami',
      'Ekadashi',
      'Dwadashi',
      'Trayodashi',
      'Chaturdashi',
      'Amavasya',
    ];
    return names[number] || `Tithi ${number}`;
  }

  private getNakshatraName(number: number): string {
    const names = [
      '',
      'Ashwini',
      'Bharani',
      'Krittika',
      'Rohini',
      'Mrigashira',
      'Ardra',
      'Punarvasu',
      'Pushya',
      'Ashlesha',
      'Magha',
      'Purva Phalguni',
      'Uttara Phalguni',
      'Hasta',
      'Chitra',
      'Swati',
      'Vishakha',
      'Anuradha',
      'Jyeshtha',
      'Mula',
      'Purva Ashadha',
      'Uttara Ashadha',
      'Shravana',
      'Dhanishta',
      'Shatabhisha',
      'Purva Bhadrapada',
      'Uttara Bhadrapada',
      'Revati',
    ];
    return names[number] || `Nakshatra ${number}`;
  }

  private getYogaName(number: number): string {
    const names = [
      '',
      'Vishkambha',
      'Priti',
      'Ayushman',
      'Saubhagya',
      'Shobhana',
      'Atiganda',
      'Sukarma',
      'Dhriti',
      'Shula',
      'Ganda',
      'Vriddhi',
      'Dhruva',
      'Vyaghata',
      'Harshana',
      'Vajra',
      'Siddhi',
      'Vyatipata',
      'Variyan',
      'Parigha',
      'Shiva',
      'Siddha',
      'Sadhya',
      'Shubha',
      'Shukla',
      'Brahma',
      'Indra',
      'Vaidhriti',
    ];
    return names[number] || `Yoga ${number}`;
  }

  private getKaranaName(number: number): string {
    const names = [
      '',
      'Bava',
      'Balava',
      'Kaulava',
      'Taitila',
      'Gara',
      'Vanija',
      'Vishti',
      'Shakuni',
      'Chatushpada',
      'Naga',
      'Kimstughna',
    ];

    if (number <= 7) {
      return names[number] || `Karana ${number}`;
    } else if (number >= 57 && number <= 60) {
      return names[number - 48] || `Karana ${number}`;
    } else {
      const cyclic = ((number - 1) % 7) + 1;
      return names[cyclic] || `Karana ${number}`;
    }
  }

  private getMasaName(number: number): string {
    const names = [
      '',
      'Chaitra',
      'Vaisakha',
      'Jyeshtha',
      'Ashadha',
      'Shravana',
      'Bhadrapada',
      'Ashwin',
      'Kartik',
      'Margashirsha',
      'Pausha',
      'Magha',
      'Phalguna',
    ];
    return names[number] || `Masa ${number}`;
  }
}
